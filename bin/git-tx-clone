#!/bin/sh
#
# Copyright (c) 2010 Google Inc johnjbarton@google.com

set -e 

SUBDIRECTORY_OK=yes
. $(dirname $0)/git-sh-setup.sh

require_clean_work_tree "tx-clone"

OPTIONS_SPEC="\
git tx-clone [--name <projectName> ] [--branch <branchname>] [--prefix <LOCAL_PATH_PREFIX>] <remote_url> <remote_path> 

Clone a remote repository subdirection into a local directory that does not yet exist.
--
n,name=              override default name for transplant branch
t,branch=            override 'master' default branch of remote
d,prefix=            override ./projectName/remote_path as directory path in local for transplant
v,verbose            echo information
x,verbose_only       echo information then exit"

die() {
	echo >&2 "$@"
	exit 1
}

usage() {
	exec "$0" -h
}

eval "$(echo "$OPTIONS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"

get_repo_base() {
	(
		cd "`/bin/pwd`" &&
		cd "$1" || cd "$1.git" &&
		{
			cd .git
			pwd
		}
	) 2>/dev/null
}


PROJECT_NAME=
REMOTE_BRANCH=
REMOTE_PATH=
LOCAL_PATH_PREFIX=
REMOTE_URL=

echo $@

while [ "$#" -ne 0 ]; do
	case "$1" in 
	-n|--name)
	    shift
		PROJECT_NAME=$1
		;;
	-t|--branch)
		shift
		REMOTE_BRANCH=$1
		;;
 	-d|--prefix)
 		shift
 		LOCAL_PATH_PREFIX=$1
 		;;
 	-v|--verbose)
 		VERBOSE=yes
 		;;
    -x|--verbose_only)
        VERBOSE_ONLY=yes
        VERBOSE=yes
        ;;
 	--)                   # some kind of marker added by rev-parse
		shift
 	    if [ "$#" -ne 2 ]; then
 	      die "$# url and path required"
 	    fi
		REMOTE_URL=$1
		shift
		REMOTE_PATH=$1
		break
		;;
	*)
		usage
		;;
	esac
	shift
done

if [ -z "$REMOTE_URL" ]; then 
  die "No remote URL"
fi

# relative to the current working directory...in the *local* tree!
# so we must be at root of the local tree

case "$REMOTE_PATH" in 
	*/)
		;;
	*?)
	    REMOTE_PATH="$REMOTE_PATH"/
	    ;;
	 *)
   		die "No remote path"
		;;
esac

# default to 'master'
if [ -z "$REMOTE_BRANCH" ]; then
  REMOTE_BRANCH="master"
fi

PROJECT_NAME=$( basename "$REMOTE_URL" .git )
if [ -z "$PROJECT_NAME" ]; then
  die "No project name"
fi

TX_REMOTE="tx.""$PROJECT_NAME"

case "$LOCAL_PATH_PREFIX" in 
	*/)
		;;
	*?)
	    LOCAL_PATH_PREFIX="$LOCAL_PATH_PREFIX"/
	    ;;
	 *)
   		LOCAL_PATH_PREFIX="$PROJECT_NAME"/
		;;
esac


# Strip refs/head/<branch> to give <branch>
#
LOCAL_BRANCH=`git symbolic-ref HEAD | sed -e 's/^.*\///'`

if [ "$VERBOSE" =  yes ]; then
  echo "git transplant remote named $TX_REMOTE"
  echo "git transplant from remote repository $REMOTE_URL"
  echo "git transplant from branch $REMOTE_BRANCH"
  echo "git transplant from directory $REMOTE_PATH"
  echo "git transplant to   directory $LOCAL_PATH_PREFIX"/"$REMOTE_PATH"
  echo "git transplant current local branch $LOCAL_BRANCH"
fi

if [ "$VERBOSE_ONLY" = yes ]; then
  exit 0
fi

set -v -x
# Fetch only one branch into our specially named remote
#
git remote add -f -t $REMOTE_BRANCH $TX_REMOTE $REMOTE_URL

# mark the local commit before our edits
#
git update-ref refs/tx/$TX_REMOTE `git rev-parse HEAD`

# move the remote subtree into our local tree
#
git archive --format=tar --prefix=$LOCAL_PATH_PREFIX refs/remotes/$TX_REMOTE/$REMOTE_BRANCH $REMOTE_PATH | tar xf -

# commit our edits
#
git add "$LOCAL_PATH_PREFIX""$REMOTE_PATH"
git commit -a -m "git tx-clone --name $PROJECT_NAME --branch $REMOTE_BRANCH --prefix $LOCAL_PATH_PREFIX $REMOTE_URL $REMOTE_PATH"
 
git --no-pager log `git rev-parse refs/tx/$TX_REMOTE`..HEAD
 
